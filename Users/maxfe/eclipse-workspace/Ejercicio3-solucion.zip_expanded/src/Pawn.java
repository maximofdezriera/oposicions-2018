import java.util.ArrayList;

/**
 * Model object for Pawn piece in the board game of Chess. It extends all the
 * attributes and methods of the parent class Piece.
 *
 * @author Maximo Fernandez Riera
 *         Taller JAVA para iniciados a la programaci√≥n
 *         Universitat Oberta de Catalunya (UOC)
 * @version 4.0
 */
public class Pawn extends Piece {

	final String white_pawn = "\u25CB";
	final String black_pawn = "\u25CF";
	// final String white_pawn = "P";
	// final String black_pawn = "p";

	/**
	 * Pawn's piece constructor. It set its parent colour attribute.
	 * 
	 * @param colour the colour of the Pawn.
	 */
	public Pawn(boolean colour) {
		super(colour);
	}

	/**
	 * This method overwrites the same method inherited from the parent class:
	 * ifFirstMove attribute is set to false and then super.move(Cell) is called.
	 * 
	 * @param cell the colour of the Pawn.
	 */
	public void move(Cell cell) {
		super.move(cell);
	}

	/**
	 * Returns the graphical representation of Pawn piece.
	 * 
	 * @return String the graphical representation of Pawn, which can be black or
	 *         white.
	 */
	public String toString() {
		if (this.getColour()) {
			return this.white_pawn;
		} else {
			return this.black_pawn;
		}
	}

	/**
	 * Returns an ArrayList with all the cells where Pawn can move.
	 * 
	 * @param chessBoard the board of the game.
	 * @return ArrayList with the available cells where Pawn can be moved.
	 * @exception ChessPlayerException throws all ChessPlayerException generated by
	 *                                 the methods used here.
	 */
	public ArrayList<Cell> getMoves(ChessBoard chessBoard) throws CheckersException {

		if (this.getColour() == Piece.WHITE) {
			return getWhiteMoves(chessBoard);
		} else {
			return getBlackMoves(chessBoard);
		}
	}

	/**
	 * Returns an ArrayList with all the cells where white Pawn can move.
	 * 
	 * @param chessBoard the board of the game.
	 * @return ArrayList with the available cells where white Pawn can be moved.
	 * @exception ChessPlayerException throws all ChessPlayerException generated by
	 *                                 the methods used here.
	 */
	private ArrayList<Cell> getWhiteMoves(ChessBoard chessBoard) throws CheckersException {

		ArrayList<Cell> moves = new ArrayList<Cell>();
		char currentX = this.cell.getCoordX();
		char currentY = this.cell.getCoordY();
		char newX;
		char newY;
		int nextMove;

		newX = (char) (currentX - 1);
		newY = (char) (currentY + 1);
		nextMove = chessBoard.nextMove(newX, newY, this.getColour());

		if ((nextMove != ChessBoard.OUT_OF_BOARD) && (nextMove == ChessBoard.EMPTY)) {
			moves.add(chessBoard.getCell("" + newX + newY));
		}

		if ((nextMove != ChessBoard.OUT_OF_BOARD) && (nextMove != ChessBoard.EMPTY)
				&& (nextMove == ChessBoard.OTHER_COLOUR)) {

			newX = (char) (currentX - 2);
			newY = (char) (currentY + 2);
			nextMove = chessBoard.nextMove(newX, newY, this.getColour());
			if ((nextMove != ChessBoard.OUT_OF_BOARD) && (nextMove == ChessBoard.EMPTY)) {
				moves.add(chessBoard.getCell("" + newX + newY));
			}
		}

		newX = (char) (currentX + 1);
		newY = (char) (currentY + 1);
		nextMove = chessBoard.nextMove(newX, newY, this.getColour());

		if ((nextMove != ChessBoard.OUT_OF_BOARD) && (nextMove == ChessBoard.EMPTY)) {
			moves.add(chessBoard.getCell("" + newX + newY));
		}

		if ((nextMove != ChessBoard.OUT_OF_BOARD) && (nextMove != ChessBoard.EMPTY)
				&& (nextMove == ChessBoard.OTHER_COLOUR)) {

			newX = (char) (currentX + 2);
			newY = (char) (currentY + 2);
			nextMove = chessBoard.nextMove(newX, newY, this.getColour());
			if ((nextMove != ChessBoard.OUT_OF_BOARD) && (nextMove == ChessBoard.EMPTY)) {
				moves.add(chessBoard.getCell("" + newX + newY));
			}
		}
		return moves;
	}

	/**
	 * Returns an ArrayList with all the cells where black Pawn can move.
	 * 
	 * @param chessBoard the board of the game.
	 * @return ArrayList with the available cells where black Pawn can be moved.
	 * @exception ChessPlayerException throws all ChessPlayerException generated by
	 *                                 the methods used here.
	 */
	private ArrayList<Cell> getBlackMoves(ChessBoard chessBoard) throws CheckersException {

		ArrayList<Cell> moves = new ArrayList<Cell>();
		char currentX = this.cell.getCoordX();
		char currentY = this.cell.getCoordY();
		char newX;
		char newY;
		int nextMove;

		newX = (char) (currentX - 1);
		newY = (char) (currentY - 1);
		nextMove = chessBoard.nextMove(newX, newY, this.getColour());

		if ((nextMove != ChessBoard.OUT_OF_BOARD) && (nextMove == ChessBoard.EMPTY)) {
			moves.add(chessBoard.getCell("" + newX + newY));
		}

		if ((nextMove != ChessBoard.OUT_OF_BOARD) && (nextMove != ChessBoard.EMPTY)
				&& (nextMove == ChessBoard.OTHER_COLOUR)) {

			newX = (char) (currentX - 2);
			newY = (char) (currentY - 2);
			nextMove = chessBoard.nextMove(newX, newY, this.getColour());
			if ((nextMove != ChessBoard.OUT_OF_BOARD) && (nextMove == ChessBoard.EMPTY)) {
				moves.add(chessBoard.getCell("" + newX + newY));
			}
		}

		newX = (char) (currentX + 1);
		newY = (char) (currentY - 1);
		nextMove = chessBoard.nextMove(newX, newY, this.getColour());

		if ((nextMove != ChessBoard.OUT_OF_BOARD) && (nextMove == ChessBoard.EMPTY)) {
			moves.add(chessBoard.getCell("" + newX + newY));
		}

		if ((nextMove != ChessBoard.OUT_OF_BOARD) && (nextMove != ChessBoard.EMPTY)
				&& (nextMove == ChessBoard.OTHER_COLOUR)) {

			newX = (char) (currentX + 2);
			newY = (char) (currentY - 2);
			nextMove = chessBoard.nextMove(newX, newY, this.getColour());
			if ((nextMove != ChessBoard.OUT_OF_BOARD) && (nextMove == ChessBoard.EMPTY)) {
				moves.add(chessBoard.getCell("" + newX + newY));
			}
		}
		return moves;
	}
}
